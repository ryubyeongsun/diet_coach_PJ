PRD – DevB (프론트엔드) 12/10 작업 지시서
0. 컨텍스트

프로젝트 이름: 남남코치 (TDEE 기반 식단 코치)

프론트 스택: Vue 3 + Vite

백엔드 스택: Spring Boot + MyBatis + MySQL (이미 구현 완료)

프론트 엔트리:

frontend/src/main.js

라우터: frontend/src/router/index.js

API 클라이언트 폴더:
frontend/src/api/

http.js

usersApi.js

mealPlanApi.js

shoppingApi.js

주요 페이지:

frontend/src/pages/MealPlanPage.vue

frontend/src/pages/ShoppingPage.vue

공통 컴포넌트:

frontend/src/components/common/NnButton.vue

frontend/src/components/common/NnCard.vue

frontend/src/components/common/NnInput.vue

메인 레이아웃 컴포넌트:

frontend/src/components/layout/NnLayout.vue (이름만 예시, 실제 이름은 코드 기준)

목표: 백엔드에 이미 구현된 API를 프론트에 제대로 연결하고, 식단/쇼핑 UX를 한 단계 올리는 것.

1. 공통 axios 클라이언트 정리 (src/api/http.js)
1-1. 요구사항

axios 인스턴스 생성

baseURL: http://localhost:8080/api

timeout: 5000ms 정도

요청/응답 인터셉터

요청:

별도 헤더 필요 없지만, 콘솔에 요청 메서드/URL 정도 로그 남겨도 됨.

응답:

백엔드 응답 형식은 아래 공통 구조 사용:

{
  "success": true,
  "message": "ok",
  "data": { ... 실제 데이터 ... }
}


success === false 이거나 HTTP 에러 발생 시 throw 해서 프론트에서 try/catch 로 처리 가능하게.

모듈 내보내기

기본 export: axiosInstance

사용 예:

import api from './http';

const res = await api.get('/users/1');

1-2. 완료 기준

http.js 하나만 import해서 모든 API 파일에서 공통으로 사용 가능해야 한다.

네트워크 에러 / 4xx / 5xx 에러 발생 시, 프론트에서 catch(err) 로 잡을 수 있어야 한다.

2. User API 모듈 (src/api/usersApi.js)
2-1. 요구사항

createUser(payload)

HTTP: POST /api/users

payload 예시:

{
  "email": "test-user@example.com",
  "password": "1234",
  "name": "테스트유저",
  "gender": "MALE",
  "birthDate": "1998-01-01",
  "height": 175,
  "weight": 70,
  "activityLevel": "MODERATE",
  "goalType": "LOSE_WEIGHT"
}


반환: res.data.data (UserProfileResponse 객체)

fetchUserProfile(userId)

HTTP: GET /api/users/{id}

반환: res.data.data

fetchUserTdee(userId)

HTTP: GET /api/users/{id}/tdee

반환: res.data.data
(BMR, TDEE, targetCalories 등)

2-2. 구현 형태
import api from './http';

export async function createUser(payload) {
  const res = await api.post('/users', payload);
  return res.data.data;
}

export async function fetchUserProfile(userId) {
  const res = await api.get(`/users/${userId}`);
  return res.data.data;
}

export async function fetchUserTdee(userId) {
  const res = await api.get(`/users/${userId}/tdee`);
  return res.data.data;
}

3. MealPlan API 모듈 (src/api/mealPlanApi.js)
3-1. 요구사항

fetchLatestMealPlan(userId)

HTTP: GET /api/users/{userId}/meal-plans/latest

반환: MealPlanOverviewResponse (백엔드 구현 기준)

구조 예시:

{
  "planId": 1,
  "userId": 1,
  "startDate": "2025-12-09",
  "endDate": "2025-01-07",
  "totalDays": 30,
  "targetCaloriesPerDay": 2056,
  "days": [
    {
      "dayId": 101,
      "date": "2025-12-09",
      "totalCalories": 2056
    },
    ...
  ]
}


generateMealPlan(payload)

HTTP: POST /api/meal-plans

payload 예시:

{
  "userId": 1,
  "startDate": "2025-12-09",
  "totalDays": 30
}


반환: 생성된 MealPlanOverviewResponse

(추후 확장용, 지금은 틀만)

fetchMealPlanDayDetail(dayId) → GET /api/meal-plans/days/{dayId}

fetchMealPlanIngredients(planId) → GET /api/meal-plans/{planId}/ingredients

3-2. 구현 형태
import api from './http';

export async function fetchLatestMealPlan(userId) {
  const res = await api.get(`/users/${userId}/meal-plans/latest`);
  return res.data.data;
}

export async function generateMealPlan(payload) {
  const res = await api.post('/meal-plans', payload);
  return res.data.data;
}

export async function fetchMealPlanDayDetail(dayId) {
  const res = await api.get(`/meal-plans/days/${dayId}`);
  return res.data.data;
}

export async function fetchMealPlanIngredients(planId) {
  const res = await api.get(`/meal-plans/${planId}/ingredients`);
  return res.data.data;
}

4. Shopping API 모듈 (src/api/shoppingApi.js)
4-1. 요구사항

searchProducts(keyword)

HTTP: GET /api/shopping/search?keyword=닭가슴살

반환: ShoppingProduct[]

구조 예시:

[
  {
    "externalId": "7813920725",
    "name": "[치킨테이블] 국내산 닭가슴살 1kg x5팩 (총5kg) 냉동",
    "price": 25000,
    "gramPerUnit": null,
    "pricePer100g": null,
    "imageUrl": "https://...",
    "productUrl": "http://...",
    "mallName": "치킨테이블"
  }
]


getRecommendations(ingredient, neededGram)

HTTP: GET /api/shopping/recommendations?ingredient=닭가슴살&neededGram=500

4-2. 구현 형태
import api from './http';

export async function searchProducts(keyword) {
  const res = await api.get('/shopping/search', {
    params: { keyword },
  });
  return res.data.data;
}

export async function getRecommendations(ingredient, neededGram) {
  const res = await api.get('/shopping/recommendations', {
    params: { ingredient, neededGram },
  });
  return res.data.data;
}

5. MealPlanPage.vue – 유저 생성 + 최신 식단 자동 로드 + 실데이터 캘린더 바인딩

파일: frontend/src/pages/MealPlanPage.vue

5-1. 요구사항

페이지 진입 시 수행 절차

localStorage에서 userId 조회

없으면:

createUser() 호출로 테스트용 유저 생성

응답에서 받은 id를 localStorage.setItem('userId', id)로 저장

있으면:

그대로 사용

fetchLatestMealPlan(userId) 호출

식단이 없으면:

화면에 "아직 생성된 식단이 없습니다. 상단 버튼을 눌러 식단을 생성해 보세요." 메시지 출력

식단이 있으면:

상단 "총 일 · 하루 목표 xxxx kcal" 텍스트에 바인딩

아래 한 달 식단 개요 카드 리스트에 days 배열 바인딩

지금은 날짜 표시는 생략하고, {{ day.totalCalories }} kcal만 보여줘도 됨 (날짜는 추후 작업)

"식단 자동 생성" 버튼 동작

클릭 시:

generateMealPlan({ userId, startDate: today, totalDays: 30 }) 호출

성공하면 fetchLatestMealPlan(userId) 다시 호출해서 화면 갱신

처리 중에는 버튼 텍스트를 "처리 중..." 으로 변경, disabled 처리

상태 관리

isLoading: API 요청 중일 때 true

errorMessage: 에러 발생 시 상단에 빨간 텍스트로 노출

currentUserId: 현재 사용자의 ID (localStorage 연동)

UI 규칙

기존 디자인(연두색 배경, 가운데 큰 카드, 아래 30개 카드)은 유지

단지 더미 데이터 → 실제 API 데이터로 치환

console.log로 현재 userId / latest overview를 한 번씩 찍어주면 디버깅에 도움됨

5-2. 구현 예시 (핵심 부분 구조)
<script setup>
import { ref, onMounted } from 'vue';
import NnButton from '../components/common/NnButton.vue';
import NnCard from '../components/common/NnCard.vue';
import { createUser } from '../api/usersApi.js';
import { fetchLatestMealPlan, generateMealPlan } from '../api/mealPlanApi.js';

const isLoading = ref(false);
const errorMessage = ref('');
const overview = ref(null);
const currentUserId = ref(null);

async function initUser() {
  let storedId = localStorage.getItem('userId');
  if (storedId) {
    currentUserId.value = Number(storedId);
    return;
  }

  const newUser = await createUser({
    email: 'test-user@example.com',
    password: '1234',
    name: '테스트유저',
    gender: 'MALE',
    birthDate: '1998-01-01',
    height: 175,
    weight: 70,
    activityLevel: 'MODERATE',
    goalType: 'LOSE_WEIGHT',
  });
  currentUserId.value = newUser.id;
  localStorage.setItem('userId', String(newUser.id));
}

async function loadLatest() {
  if (!currentUserId.value) return;
  isLoading.value = true;
  errorMessage.value = '';
  try {
    overview.value = await fetchLatestMealPlan(currentUserId.value);
  } catch (err) {
    console.error(err);
    errorMessage.value = '식단 정보를 불러오는 중 오류가 발생했습니다.';
  } finally {
    isLoading.value = false;
  }
}

async function onClickGenerate() {
  if (!currentUserId.value) return;
  isLoading.value = true;
  errorMessage.value = '';
  try {
    const today = new Date().toISOString().slice(0, 10);
    await generateMealPlan({
      userId: currentUserId.value,
      startDate: today,
      totalDays: 30,
    });
    await loadLatest();
  } catch (err) {
    console.error(err);
    errorMessage.value = '식단 생성 중 오류가 발생했습니다.';
  } finally {
    isLoading.value = false;
  }
}

onMounted(async () => {
  await initUser();
  await loadLatest();
});
</script>


템플릿 부분은 현재 디자인을 유지하면서 overview와 overview.days를 사용해 30개 카드에 day.totalCalories를 뿌리도록 수정.

6. ShoppingPage.vue – 검색/추천 UI & API 연동

파일: frontend/src/pages/ShoppingPage.vue

6-1. 요구사항

검색 바 + 버튼으로 검색 동작

검색어 입력 후 버튼 클릭 시:

searchProducts(keyword) 호출

결과를 searchResults 배열에 저장

동시에 같은 키워드로 getRecommendations(keyword, 500) 호출

recommendations 배열에 저장

화면 구성

상단 설명 텍스트 유지:
"11번가 API와 연동해, 식단에 필요한 재료를 가져와 가격 비교와 함께 추천해주는 화면입니다." 비슷하게 유지

아래 레이아웃:

왼쪽: "검색 결과" 카드 리스트

오른쪽: "추천 상품" 카드 리스트

각 상품 카드에 표시:

상품 이미지 (imageUrl)

상품 이름 (name)

가격 (price 원)

판매처 (mallName)

"11번가에서 보기" 버튼 (productUrl로 window.open)

상태

isLoadingSearch, isLoadingRecommend

errorMessage

검색 결과 / 추천 결과가 없을 때의 안내 문구

6-2. 완료 기준

검색어 입력 → 검색 버튼 클릭 →
Network 탭에서 /api/shopping/search와 /api/shopping/recommendations가 실제로 호출되고,
그 결과가 화면 카드로 렌더링되어야 한다.

오류 발생 시 "검색 중 오류가 발생했습니다." 등의 메시지 한 줄이 화면에 노출되어야 한다.

7. 완료 정의 (Definition of Done)

앱 실행 후 /meal-plans 진입 시:

최초 한 번만 테스트 유저가 생성되고 localStorage에 userId가 저장된다.

새로고침해도 같은 유저 ID가 유지된다.

"식단 자동 생성" 버튼을 누르면 실제로 30일 식단이 생성되고, 30개의 카드에 동일 kcal 값이라도 표시된다.

/shopping 페이지에서:

키워드를 입력해 검색하면 실제 11번가 API 연동 결과가 리스트로 뜬다.

추천 섹션에도 동일 키워드 기반 추천 상품이 뜬다.

모든 API 호출은 src/api/http.js에서 만든 axios 인스턴스를 통해 수행된다.

콘솔 에러가 없어야 하고, Network 탭에서 4xx/5xx가 발생하지 않는 상태여야 한다.